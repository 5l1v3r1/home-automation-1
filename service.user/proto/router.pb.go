// Code generated by protoc-gen-jrpc. DO NOT EDIT.

package userproto

import (
	"net/http"

	"github.com/jakewright/home-automation/libraries/go/errors"
	"github.com/jakewright/home-automation/libraries/go/request"
	"github.com/jakewright/home-automation/libraries/go/response"
	"github.com/jakewright/home-automation/libraries/go/router"
	"github.com/jakewright/home-automation/libraries/go/rpc"
	"github.com/jakewright/home-automation/libraries/go/slog"
)

// UserRouter wraps router.Router to provide a convenient way to set handlers
type UserRouter struct {
	*router.Router
	GetUser func(*GetUserRequest) (*GetUserResponse, error)
}

// NewRouter returns a router that is ready to add handlers to
func NewRouter() *UserRouter {
	rr := &UserRouter{
		Router: router.New(),
	}

	rr.Router.Handle("GET", "/user/", func(w http.ResponseWriter, r *http.Request) {
		if rr.GetUser == nil {
			slog.Panicf("No handler exists for GET service.user/user/")
		}

		body := &GetUserRequest{}
		if err := request.Decode(r, body); err != nil {
			err = errors.Wrap(err, errors.ErrBadRequest, "failed to decode request")
			slog.Error(err)
			response.WriteJSON(w, err)
			return
		}

		if err := body.Validate(); err != nil {
			err = errors.Wrap(err, errors.ErrBadRequest, "failed to validate request")
			slog.Error(err)
			response.WriteJSON(w, err)
			return
		}

		rsp, err := rr.GetUser(body)
		if err != nil {
			err = errors.WithMessage(err, "failed to handle request")
			slog.Error(err)
			response.WriteJSON(w, err)
			return
		}

		response.WriteJSON(w, rsp)
	})

	return rr
}

// Do makes performs the request
func (m *GetUserRequest) Do() (*GetUserResponse, error) {
	req := &rpc.Request{
		Method: "GET",
		URL:    "service.user/user/",
		Body:   m,
	}

	rsp := &GetUserResponse{}
	_, err := rpc.Do(req, rsp)
	return rsp, err
}
