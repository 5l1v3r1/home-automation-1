package main

import (
	"fmt"
	"net/http"
	"path"
	"regexp"
	"text/template"

	"github.com/jakewright/home-automation/libraries/go/svcdef"
)

var routerTemplate *template.Template

func init() {
	var err error
	routerTemplate, err = template.New("router_template").Parse(routerTemplateText)
	if err != nil {
		panic(err)
	}
}

type endpoint struct {
	Name       string
	InputType  string
	OutputType string
	HTTPMethod string
	Path       string
	URL        string
}

type imp struct {
	Alias string
	Path  string
}

type routerData struct {
	PackageDir  string
	PackageName string
	RouterName  string
	Imports     []*imp
	Endpoints   []*endpoint
}

const routerTemplateText = `// Code generated by jrpc. DO NOT EDIT.

package {{ .PackageName }}

{{ if .Imports }}
	import (
		{{- range .Imports }}
			{{ .Alias }} "{{ .Path }}"
		{{- end}}
	)
{{ end }}

// {{ .RouterName }} wraps router.Router to provide a convenient way to set handlers
type {{ .RouterName }} struct {
	*router.Router
	{{- range .Endpoints }}
		{{ .Name }} func(*{{ .InputType }}) (*{{ .OutputType }}, error)
	{{- end }}
}

// NewRouter returns a router that is ready to add handlers to
func NewRouter() *{{ .RouterName }} {
	rr := &{{ .RouterName }}{
		Router: router.New(),
	}

	{{ range .Endpoints }}
		rr.Router.Handle("{{ .HTTPMethod }}", "{{ .Path }}", func(w http.ResponseWriter, r *http.Request) {
			if rr.{{ .Name }} == nil {
				slog.Panicf("No handler exists for {{ .HTTPMethod }} {{ .URL }}")
			}

			body := &{{ .InputType }}{}
			if err := request.Decode(r, body); err != nil {
				err = errors.Wrap(err, errors.ErrBadRequest, "failed to decode request")
				slog.Error(err)
				response.WriteJSON(w, err)
				return
			}

			if err := body.Validate(); err != nil {
				err = errors.Wrap(err, errors.ErrBadRequest, "failed to validate request")
				slog.Error(err)
				response.WriteJSON(w, err)
				return
			}

			rsp, err := rr.{{ .Name }}(body)
			if err != nil {
				err = errors.WithMessage(err, "failed to handle request")
				slog.Error(err)
				response.WriteJSON(w, err)
				return
			}

			response.WriteJSON(w, rsp)
		})
	{{ end }}

	return rr
}
`

func createRouterTemplateData(opts *options, file *svcdef.File) (*routerData, error) {
	packageName := packageDirRouter
	if opts.RouterPackageName != "" {
		packageName = opts.RouterPackageName
	}

	// Figure out the path of the package we're generating code for
	self, err := getGoImportPath(opts.DefPath, packageName)
	if err != nil {
		return nil, err
	}

	im := newImportManager(self)
	im.add("net/http")

	// Make sure the service name is a suitable go struct name
	r := regexp.MustCompile(`^[A-Z][a-zA-Z0-9]*`)
	if ok := r.MatchString(file.Service.Name); !ok {
		return nil, fmt.Errorf("service name should be alphanumeric camelcase")
	}

	routerPath, ok := file.Service.Options["path"].(string)
	if !ok {
		return nil, fmt.Errorf("path not set on service")
	}

	if len(file.Service.RPCs) == 0 {
		return nil, nil
	}

	endpoints := make([]*endpoint, len(file.Service.RPCs))

	for i, r := range file.Service.RPCs {
		method, err := getMethod(r)
		if err != nil {
			return nil, err
		}

		rpcPath, err := getPath(r)
		if err != nil {
			return nil, err
		}

		inType, err := resolveTypeName(r.InputType, opts.DefPath, file.Imports, im)
		if err != nil {
			return nil, err
		}

		outType, err := resolveTypeName(r.OutputType, opts.DefPath, file.Imports, im)
		if err != nil {
			return nil, err
		}

		endpoints[i] = &endpoint{
			Name:       r.Name,
			InputType:  inType,
			OutputType: outType,
			HTTPMethod: method,
			Path:       rpcPath,
			URL:        path.Join(routerPath, rpcPath),
		}
	}

	return &routerData{
		PackageDir:  packageName,
		PackageName: packageName,
		RouterName:  file.Service.Name + "Router",
		Imports:     im.get(),
		Endpoints:   endpoints,
	}, nil
}

func getMethod(r *svcdef.RPC) (string, error) {
	method, ok := r.Options["method"].(string)
	if !ok {
		return "", fmt.Errorf("method option not set on RPC %s", r.Name)
	}

	switch method {
	case http.MethodGet,
		http.MethodHead,
		http.MethodPost,
		http.MethodPut,
		http.MethodPatch,
		http.MethodDelete,
		http.MethodConnect,
		http.MethodOptions,
		http.MethodTrace:
		return method, nil
	}

	return "", fmt.Errorf("invalid method on RPC %s: %s", r.Name, method)
}

func getPath(r *svcdef.RPC) (string, error) {
	p, ok := r.Options["path"].(string)
	if !ok {
		return "", fmt.Errorf("path option not set on RPC %s", r.Name)
	}

	if p[0] != '/' {
		return "", fmt.Errorf("path on RPC %s must start with a /", r.Name)
	}

	return p, nil
}
