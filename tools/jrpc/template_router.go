package main

import (
	"fmt"
	"strings"
	"text/template"

	"github.com/jakewright/home-automation/tools/jrpc/imports"
)

const packageDirRouter = "handler"

type routerDataEndpoint struct {
	NameUpper  string
	InputType  string
	OutputType string
	HTTPMethod string
	Path       string
}

type routerData struct {
	PackageName string
	Imports     []*imports.Imp
	Endpoints   []*routerDataEndpoint
}

const routerTemplateText = `// Code generated by jrpc. DO NOT EDIT.

package {{ .PackageName }}

{{ if .Imports }}
	import (
		{{- range .Imports }}
			{{ .Alias }} "{{ .Path }}"
		{{- end}}
	)
{{ end }}

type controller interface {
	{{- range .Endpoints }}
		{{ .NameUpper }}(*Request, *{{ .InputType }}) (*{{ .OutputType }}, error)
	{{- end }}
}

// Request wraps http.Request but exposes the context
type Request struct {
	context.Context
	*http.Request
}

// NewRouter returns a router with appropriate handlers set
func NewRouter(c controller) *router.Router {
	r := router.New()

	{{ range .Endpoints }}
		r.Handle("{{ .HTTPMethod }}", "{{ .Path }}", func(w http.ResponseWriter, r *http.Request) {
			body := &{{ .InputType }}{}
			if err := request.Decode(r, body); err != nil {
				err = oops.Wrap(err, oops.ErrBadRequest, "failed to decode request")
				slog.Error(err)
				response.WriteJSON(w, err)
				return
			}

			if err := body.Validate(); err != nil {
				err = oops.Wrap(err, oops.ErrBadRequest, "failed to validate request")
				slog.Error(err)
				response.WriteJSON(w, err)
				return
			}

			req := &Request{
				Context: r.Context(),
				Request: r,
			}

			rsp, err := c.{{ .NameUpper }}(req, body)
			if err != nil {
				err = oops.WithMessage(err, "failed to handle request")
				slog.Error(err)
				response.WriteJSON(w, err)
				return
			}

			response.WriteJSON(w, rsp)
		})
	{{ end }}

	return r
}

`

type routerGenerator struct {
	baseGenerator
}

func (g *routerGenerator) Template() (*template.Template, error) {
	return template.New("router_template").Parse(routerTemplateText)
}

func (g *routerGenerator) PackageDir() string {
	packageDir := packageDirRouter
	if g.options.RouterPackageName != "" {
		packageDir = g.options.RouterPackageName
	}
	return packageDir
}

func (g *routerGenerator) Data(im *imports.Manager) (interface{}, error) {
	// Don't generate anything if there's no service definition
	if g.file.Service == nil {
		return nil, nil
	}

	im.Add("context")
	im.Add("net/http")

	// Make sure the service name is a suitable go struct name
	if ok := reValidGoStruct.MatchString(g.file.Service.Name); !ok {
		return "", fmt.Errorf("service name should be alphanumeric camelcase")
	}

	if g.file.Service == nil {
		return nil, nil
	}

	if len(g.file.Service.RPCs) == 0 {
		return nil, nil
	}

	endpoints := make([]*routerDataEndpoint, len(g.file.Service.RPCs))
	for i, r := range g.file.Service.RPCs {
		nameUpper := strings.ToUpper(r.Name[0:1]) + r.Name[1:]

		method, err := getMethod(r)
		if err != nil {
			return nil, fmt.Errorf("failed to get RPC %q method: %w", r.Name, err)
		}

		rpcPath, err := getPath(r)
		if err != nil {
			return nil, fmt.Errorf("failed to get RPC %q path: %w", r.Name, err)
		}

		inType, err := resolveTypeName(r.InputType, g.file, im)
		if err != nil {
			return nil, fmt.Errorf("failed to resolve RPC %q input type: %w", r.Name, err)
		}

		outType, err := resolveTypeName(r.OutputType, g.file, im)
		if err != nil {
			return nil, fmt.Errorf("failed to resolve RPC %q output type: %w", r.Name, err)
		}

		endpoints[i] = &routerDataEndpoint{
			NameUpper:  nameUpper,
			InputType:  inType.TypeName,
			OutputType: outType.TypeName,
			HTTPMethod: method,
			Path:       rpcPath,
		}
	}

	return &routerData{
		PackageName: g.PackageDir(), // This doesn't support separate package name to dir
		Imports:     im.Get(),
		Endpoints:   endpoints,
	}, nil
}

func (g *routerGenerator) Filename() string {
	return "gen.go"
}
