package main

import (
	"fmt"
	"strings"
	"text/template"

	"github.com/jakewright/home-automation/tools/jrpc/imports"
)

const packageDirRouter = "handler"

type routerDataEndpoint struct {
	NameLower  string
	NameUpper  string
	InputType  string
	OutputType string
	HTTPMethod string
	Path       string
}

type routerData struct {
	PackageName string
	Imports     []*imports.Imp
	RouterName  string
	Endpoints   []*routerDataEndpoint
}

const routerTemplateText = `// Code generated by jrpc. DO NOT EDIT.

package {{ .PackageName }}

{{ if .Imports }}
	import (
		{{- range .Imports }}
			{{ .Alias }} "{{ .Path }}"
		{{- end}}
	)
{{ end }}

// Request wraps http.Request but exposes the context
type Request struct {
	context.Context
	*http.Request
}

// {{ .RouterName }} wraps router.Router to provide a convenient way to set handlers
type {{ .RouterName }} struct {
	*router.Router
	{{- range .Endpoints }}
		{{ .NameLower }} func(*Request, *{{ .InputType }}) (*{{ .OutputType }}, error)
	{{- end }}
	{{- range .Endpoints }}
		{{ .NameLower }}HandlerFunc http.HandlerFunc
	{{- end}}
}

// NewRouter returns a router that is ready to add handlers to
func NewRouter() *{{ .RouterName }} {
	rr := &{{ .RouterName }}{
		Router: router.New(),
	}

	{{ range .Endpoints }}
		rr.{{ .NameLower }}HandlerFunc = func(w http.ResponseWriter, r *http.Request) {
			if rr.{{ .NameLower }} == nil {
				slog.Panicf("No handler exists for {{ .HTTPMethod }} {{ .Path }}")
			}

			body := &{{ .InputType }}{}
			if err := request.Decode(r, body); err != nil {
				err = oops.Wrap(err, oops.ErrBadRequest, "failed to decode request")
				slog.Error(err)
				response.WriteJSON(w, err)
				return
			}

			if err := body.Validate(); err != nil {
				err = oops.Wrap(err, oops.ErrBadRequest, "failed to validate request")
				slog.Error(err)
				response.WriteJSON(w, err)
				return
			}

			req := &Request{
				Context: r.Context(),
				Request: r,
			}

			rsp, err := rr.{{ .NameLower }}(req, body)
			if err != nil {
				err = oops.WithMessage(err, "failed to handle request")
				slog.Error(err)
				response.WriteJSON(w, err)
				return
			}

			response.WriteJSON(w, rsp)
		}

		rr.Router.Handle("{{ .HTTPMethod }}", "{{ .Path }}", rr.{{ .NameLower }}HandlerFunc)
	{{ end }}

	return rr
}

{{ $routerName := .RouterName }}

{{- range .Endpoints }}
	func (r *{{ $routerName }}) {{ .NameUpper }}(f func(*Request, *{{ .InputType }}) (*{{ .OutputType }}, error)) *{{ $routerName }} {
		r.{{ .NameLower }} = f
		return r
	}
{{ end }}

`

type routerGenerator struct {
	baseGenerator
}

func (g *routerGenerator) Template() (*template.Template, error) {
	return template.New("router_template").Parse(routerTemplateText)
}

func (g *routerGenerator) PackageDir() string {
	packageDir := packageDirRouter
	if g.options.RouterPackageName != "" {
		packageDir = g.options.RouterPackageName
	}
	return packageDir
}

func (g *routerGenerator) Data(im *imports.Manager) (interface{}, error) {
	// Don't generate anything if there's no service definition
	if g.file.Service == nil {
		return nil, nil
	}

	im.Add("context")
	im.Add("net/http")

	// Make sure the service name is a suitable go struct name
	if ok := reValidGoStruct.MatchString(g.file.Service.Name); !ok {
		return "", fmt.Errorf("service name should be alphanumeric camelcase")
	}
	routerName := g.file.Service.Name + "Router"

	if g.file.Service == nil {
		return nil, nil
	}

	if len(g.file.Service.RPCs) == 0 {
		return nil, nil
	}

	endpoints := make([]*routerDataEndpoint, len(g.file.Service.RPCs))
	for i, r := range g.file.Service.RPCs {
		nameLower := strings.ToLower(r.Name[0:1]) + r.Name[1:]
		nameUpper := strings.ToUpper(r.Name[0:1]) + r.Name[1:]

		method, err := getMethod(r)
		if err != nil {
			return nil, fmt.Errorf("failed to get RPC %q method: %w", r.Name, err)
		}

		rpcPath, err := getPath(r)
		if err != nil {
			return nil, fmt.Errorf("failed to get RPC %q path: %w", r.Name, err)
		}

		inType, err := resolveTypeName(r.InputType, g.file, im)
		if err != nil {
			return nil, fmt.Errorf("failed to resolve RPC %q input type: %w", r.Name, err)
		}

		outType, err := resolveTypeName(r.OutputType, g.file, im)
		if err != nil {
			return nil, fmt.Errorf("failed to resolve RPC %q output type: %w", r.Name, err)
		}

		endpoints[i] = &routerDataEndpoint{
			NameLower:  nameLower,
			NameUpper:  nameUpper,
			InputType:  inType.TypeName,
			OutputType: outType.TypeName,
			HTTPMethod: method,
			Path:       rpcPath,
		}
	}

	return &routerData{
		PackageName: g.PackageDir(), // This doesn't support separate package name to dir
		Imports:     im.Get(),
		RouterName:  routerName,
		Endpoints:   endpoints,
	}, nil
}

func (g *routerGenerator) Filename() string {
	return "gen.go"
}
