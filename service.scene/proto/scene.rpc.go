// Code generated by protoc-gen-jrpc. DO NOT EDIT.

package sceneproto

import (
	"encoding/json"
	"net/http"
	"time"

	"github.com/jakewright/home-automation/libraries/go/request"
	"github.com/jakewright/home-automation/libraries/go/response"
	"github.com/jakewright/home-automation/libraries/go/router"
	"github.com/jakewright/home-automation/libraries/go/rpc"
	"github.com/jakewright/home-automation/libraries/go/slog"
)

// SceneRouter wraps router.Router to provide a convenient way to set handlers
type SceneRouter struct {
	*router.Router
	CreateScene func(*CreateSceneRequest) (*CreateSceneResponse, error)
	ReadScene   func(*ReadSceneRequest) (*ReadSceneResponse, error)
	ListScenes  func(*ListScenesRequest) (*ListScenesResponse, error)
	DeleteScene func(*DeleteSceneRequest) (*DeleteSceneResponse, error)
	SetScene    func(*SetSceneRequest) (*SetSceneResponse, error)
}

// NewRouter returns a router that is ready to add handlers to
func NewRouter() *SceneRouter {
	rr := &SceneRouter{
		Router: router.New(),
	}

	rr.Router.Handle("POST", "/scenes", func(w http.ResponseWriter, r *http.Request) {
		body := &CreateSceneRequest{}
		if err := request.Decode(r, body); err != nil {
			response.WriteJSON(w, err)
			return
		}

		if rr.CreateScene == nil {
			slog.Panic("No handler exists for POST service.scene/scenes")
		}

		rsp, err := rr.CreateScene(body)
		if err != nil {
			slog.Error("Failed to handle request: %v", err)
			response.WriteJSON(w, err)
			return
		}

		response.WriteJSON(w, rsp)
	})

	rr.Router.Handle("GET", "/scene", func(w http.ResponseWriter, r *http.Request) {
		body := &ReadSceneRequest{}
		if err := request.Decode(r, body); err != nil {
			response.WriteJSON(w, err)
			return
		}

		if rr.ReadScene == nil {
			slog.Panic("No handler exists for GET service.scene/scene")
		}

		rsp, err := rr.ReadScene(body)
		if err != nil {
			slog.Error("Failed to handle request: %v", err)
			response.WriteJSON(w, err)
			return
		}

		response.WriteJSON(w, rsp)
	})

	rr.Router.Handle("GET", "/scenes", func(w http.ResponseWriter, r *http.Request) {
		body := &ListScenesRequest{}
		if err := request.Decode(r, body); err != nil {
			response.WriteJSON(w, err)
			return
		}

		if rr.ListScenes == nil {
			slog.Panic("No handler exists for GET service.scene/scenes")
		}

		rsp, err := rr.ListScenes(body)
		if err != nil {
			slog.Error("Failed to handle request: %v", err)
			response.WriteJSON(w, err)
			return
		}

		response.WriteJSON(w, rsp)
	})

	rr.Router.Handle("DELETE", "/scene", func(w http.ResponseWriter, r *http.Request) {
		body := &DeleteSceneRequest{}
		if err := request.Decode(r, body); err != nil {
			response.WriteJSON(w, err)
			return
		}

		if rr.DeleteScene == nil {
			slog.Panic("No handler exists for DELETE service.scene/scene")
		}

		rsp, err := rr.DeleteScene(body)
		if err != nil {
			slog.Error("Failed to handle request: %v", err)
			response.WriteJSON(w, err)
			return
		}

		response.WriteJSON(w, rsp)
	})

	rr.Router.Handle("POST", "/scene/set", func(w http.ResponseWriter, r *http.Request) {
		body := &SetSceneRequest{}
		if err := request.Decode(r, body); err != nil {
			response.WriteJSON(w, err)
			return
		}

		if rr.SetScene == nil {
			slog.Panic("No handler exists for POST service.scene/scene/set")
		}

		rsp, err := rr.SetScene(body)
		if err != nil {
			slog.Error("Failed to handle request: %v", err)
			response.WriteJSON(w, err)
			return
		}

		response.WriteJSON(w, rsp)
	})

	return rr
}

// Do makes performs the request
func (m *CreateSceneRequest) Do() (*CreateSceneResponse, error) {
	req := &rpc.Request{
		Method: "POST",
		URL:    "service.scene/scenes",
		Body:   m,
	}

	rsp := &CreateSceneResponse{}
	_, err := rpc.Do(req, rsp)
	return rsp, err
}

// Do makes performs the request
func (m *ReadSceneRequest) Do() (*ReadSceneResponse, error) {
	req := &rpc.Request{
		Method: "GET",
		URL:    "service.scene/scene",
		Body:   m,
	}

	rsp := &ReadSceneResponse{}
	_, err := rpc.Do(req, rsp)
	return rsp, err
}

// Do makes performs the request
func (m *ListScenesRequest) Do() (*ListScenesResponse, error) {
	req := &rpc.Request{
		Method: "GET",
		URL:    "service.scene/scenes",
		Body:   m,
	}

	rsp := &ListScenesResponse{}
	_, err := rpc.Do(req, rsp)
	return rsp, err
}

// Do makes performs the request
func (m *DeleteSceneRequest) Do() (*DeleteSceneResponse, error) {
	req := &rpc.Request{
		Method: "DELETE",
		URL:    "service.scene/scene",
		Body:   m,
	}

	rsp := &DeleteSceneResponse{}
	_, err := rpc.Do(req, rsp)
	return rsp, err
}

// Do makes performs the request
func (m *SetSceneRequest) Do() (*SetSceneResponse, error) {
	req := &rpc.Request{
		Method: "POST",
		URL:    "service.scene/scene/set",
		Body:   m,
	}

	rsp := &SetSceneResponse{}
	_, err := rpc.Do(req, rsp)
	return rsp, err
}

// UnmarshalJSON unmarshals normally but validates fields
func (m *Scene) UnmarshalJSON(data []byte) error {
	type Alias Scene
	a := (*Alias)(m)
	if err := json.Unmarshal(data, a); err != nil {
		return err
	}

	if m.CreatedAt != "" {
		if _, err := time.Parse(time.RFC3339Nano, m.CreatedAt); err != nil {
			return err
		}
	}

	if m.UpdatedAt != "" {
		if _, err := time.Parse(time.RFC3339Nano, m.UpdatedAt); err != nil {
			return err
		}
	}

	if m.DeletedAt != "" {
		if _, err := time.Parse(time.RFC3339Nano, m.DeletedAt); err != nil {
			return err
		}
	}

	return nil
}

// UnmarshalJSON unmarshals normally but validates fields
func (m *Action) UnmarshalJSON(data []byte) error {
	type Alias Action
	a := (*Alias)(m)
	if err := json.Unmarshal(data, a); err != nil {
		return err
	}

	if m.CreatedAt != "" {
		if _, err := time.Parse(time.RFC3339Nano, m.CreatedAt); err != nil {
			return err
		}
	}

	if m.UpdatedAt != "" {
		if _, err := time.Parse(time.RFC3339Nano, m.UpdatedAt); err != nil {
			return err
		}
	}

	if m.DeletedAt != "" {
		if _, err := time.Parse(time.RFC3339Nano, m.DeletedAt); err != nil {
			return err
		}
	}

	return nil
}

// Get CreatedAtTime parses CreatedAt as a time
func (m *Scene) GetCreatedAtTime() time.Time {
	if m.GetCreatedAt() == "" {
		return time.Time{}
	}

	// Ignore the error because it will have already
	// been validated by the unmarshal function
	t, _ := time.Parse(time.RFC3339Nano, m.GetCreatedAt())
	return t
}

// Get UpdatedAtTime parses UpdatedAt as a time
func (m *Scene) GetUpdatedAtTime() time.Time {
	if m.GetUpdatedAt() == "" {
		return time.Time{}
	}

	// Ignore the error because it will have already
	// been validated by the unmarshal function
	t, _ := time.Parse(time.RFC3339Nano, m.GetUpdatedAt())
	return t
}

// Get DeletedAtTime parses DeletedAt as a time
func (m *Scene) GetDeletedAtTime() time.Time {
	if m.GetDeletedAt() == "" {
		return time.Time{}
	}

	// Ignore the error because it will have already
	// been validated by the unmarshal function
	t, _ := time.Parse(time.RFC3339Nano, m.GetDeletedAt())
	return t
}

// Get CreatedAtTime parses CreatedAt as a time
func (m *Action) GetCreatedAtTime() time.Time {
	if m.GetCreatedAt() == "" {
		return time.Time{}
	}

	// Ignore the error because it will have already
	// been validated by the unmarshal function
	t, _ := time.Parse(time.RFC3339Nano, m.GetCreatedAt())
	return t
}

// Get UpdatedAtTime parses UpdatedAt as a time
func (m *Action) GetUpdatedAtTime() time.Time {
	if m.GetUpdatedAt() == "" {
		return time.Time{}
	}

	// Ignore the error because it will have already
	// been validated by the unmarshal function
	t, _ := time.Parse(time.RFC3339Nano, m.GetUpdatedAt())
	return t
}

// Get DeletedAtTime parses DeletedAt as a time
func (m *Action) GetDeletedAtTime() time.Time {
	if m.GetDeletedAt() == "" {
		return time.Time{}
	}

	// Ignore the error because it will have already
	// been validated by the unmarshal function
	t, _ := time.Parse(time.RFC3339Nano, m.GetDeletedAt())
	return t
}
